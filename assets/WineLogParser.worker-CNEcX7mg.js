(function(){"use strict";var w=(t=>(t.CALL="Call",t.RETURN="Ret",t.TEXT="Text",t))(w||{});async function*U(t,e){var l,h;let i=0;const u=new TextDecoder("utf8"),T=t.getReader();let s=await T.read();s.value&&(i+=s.value.length,(l=e==null?void 0:e.onReadProgress)==null||l.call(e,i));let c=s.value?u.decode(s.value,{stream:!0}):"";const E=/\r?\n/gm;let m=0;for(;;){const d=E.exec(c);if(!d){if(s.done)break;const a=c.slice(m);s=await T.read(),s.value&&(i+=s.value.length,(h=e==null?void 0:e.onReadProgress)==null||h.call(e,i));const p=s.value?u.decode(s.value,{stream:!0}):"";c=a+p,m=E.lastIndex=0;continue}yield c.substring(m,d.index),m=E.lastIndex}m<c.length&&(yield c.slice(m))}const F=/^\d+\.\d+:/,N=/(?:(?<timestamp>\d+\.\d+):)?(?<pid>[a-f0-9]{4}):(?<tid>[a-f0-9]{4}):(?<type>[^\s]+)\s*(?<message>.*)/,O=/(?:(?:(?<module>[\w]+)\.(?<func>[\w]+))|(?<unknown>.+))\((?<args>.+)?\)(?: retval=(?<retval>[a-f0-9]+))?(?: ret=(?<callsite>[a-f0-9]+))?/,P=/L"(?<string>.+)"/,W=/[^\\]+$/;async function M(t,e){if(typeof t=="string")return M(new Blob([t]),e);if(t instanceof Blob)return M(t.stream(),e);const i=t,u=[],T={},s={},c={},E={},m=U(i,{onReadProgress:e==null?void 0:e.onReadProgress});let l=0,h=1;const d=[];let a="",p=0,_;for(;;){if(l===2&&(d.length?a=d.shift():l=0),l!==2){const n=await m.next();if(n.done)break;a=n.value}const b=N.exec(a.slice(h));if(b){if(h===1){const n=F.exec(a);if(n){h=n[0].length+1,l=2,d.push(a);continue}}l=1,d.push(a.slice(0,b.index+h),a.slice(b.index+h));continue}const H=a.match(N);if(H){if(l===1){d.push(a);continue}}else{if(l===1)d[0]+=a,l=2;else{const n={id:p,type:w.TEXT,text:a};u.push(n),++p}continue}const{pid:r,tid:g,type:C,message:v,timestamp:$}=H.groups;let R=T[r];R||(R={id:r,name:null,threads:[]},T[r]=R,s[r]={},c[r]={},E[r]={});let x=s[r][g];x||(x={id:g,name:null},s[r][g]=x,T[r].threads.push(x));const o=c[r][g];let f;const L={id:p,process:R,thread:x};if($){const n=parseFloat($)*1e3|0;_||(_=n),L.time=n-_}switch(C){case w.CALL:case w.RETURN:const n=v.match(O);if(!n)throw new Error(`could not parse Call/Ret line: '${a}'`);const{groups:{unknown:X,module:j,func:G,args:I,retval:V,callsite:q}}=n;if(X)continue;const S={module:j,func:G,callsite:q};C===w.CALL?(f={type:w.CALL,...L,...S,args:I==null?void 0:I.split(",")},c[r][g]=f):(f={type:w.RETURN,...L,...S,retval:V},o&&f.callsite===o.callsite&&(o.return=f,E[r][g]===o&&(o.inlinable=!0)),c[r][g]=o==null?void 0:o.parent);break;default:const[A,k="",B=""]=C.split(":"),D=A==="fixme"||A==="err"||A==="warn"||A==="trace";if(f={...L,channel:k,class:D?A:"trace",logger:B,message:D?v:`${C} ${v}`},k==="threadname"){const y=v.match(P);y&&(x.name=y.groups.string)}else if(k==="module"&&B==="get_load_order"){const y=v.match(P);if(y&&!R.path&&(R.path=y.groups.string.replaceAll("\\\\","\\"),R.name=R.path.match(W)[0]),!y)throw new Error(`could not extract wide string from message: ${v}`)}}o&&(f.parent=o),u.push(f),E[r][g]=f,++p}return{processes:Object.values(T),entries:u}}self.addEventListener("message",async t=>{const e=t.data;try{const i=await M(e,{onReadProgress(u){self.postMessage({type:"progress",bytesRead:u})}});self.postMessage({type:"complete",result:i})}catch(i){self.postMessage({type:"error",error:i})}})})();
